# Качественный аудит проекта 1tips (27.02.2026)

Проверены безопасность, корректность логики, качество кода и согласованность внесённых изменений.

---

## 1. Состояние после исправлений (аудит 27.02)

| Пункт из первого аудита | Статус |
|-------------------------|--------|
| CSRF на login/register | ✅ Включено (`verifyCsrfFromRequest`) |
| API-ключ не в ответе профиля | ✅ В ответе только `hasApiKey` |
| API-ключ в БД как хеш | ✅ Новые ключи: `apiKeyPrefix` + `apiKeyHash`, legacy по `apiKey` |
| Явная ошибка при отсутствии NEXT_PUBLIC_APP_URL в production | ✅ Сообщение «Задайте NEXT_PUBLIC_APP_URL в окружении (production)» |
| Seed: нет дефолтного пароля суперадмина в production | ✅ При `NODE_ENV=production` без `SUPERADMIN_PASSWORD` — exit(1) |
| Webhook при ошибке возвращает 503 | ✅ В `catch` возвращается 503 для повтора |
| Redis для rate limit | ❌ Не делали (один инстанс) |

---

## 2. Безопасность

### 2.1 Аутентификация и авторизация

- **JWT:** Access 15 мин, refresh в httpOnly cookie, проверка сессии в БД при refresh, блокировка пользователя учитывается. ✅
- **API-ключ:** Поиск по префиксу/legacy, сравнение по хешу (timing-safe). Новые ключи в БД только хеш. ✅
- **RBAC:** Админ-маршруты за `requireRole(["ADMIN"]|["SUPERADMIN"])`, SUPERADMIN имеет доступ к эндпоинтам ADMIN. ✅
- **CSRF:** Login, register, logout (без Bearer) проверяют `verifyCsrfFromRequest`. Остальные мутирующие с Bearer — без CSRF (запрос с другого сайта не понесёт Bearer). ✅
- **Чеки выплат:** Доступ только владелец или SUPERADMIN; проверка `payout.userId === userId` или `role === "SUPERADMIN"`. ✅

### 2.2 Замечание: роль при авторизации по API-ключу

При авторизации через `X-API-Key` в `requireAuthOrApiKey` возвращается только `userId`, без `role`. В маршруте чека `authResult.role === "SUPERADMIN"` даёт расширенный доступ только при Bearer. То есть суперадмин, заходя по API-ключу, не сможет скачать чек чужой выплаты. Это осознанное ограничение (суперадмин обычно через веб с Bearer). При необходимости можно подгружать `role` из БД по `userId` для маршрутов, где нужен расширенный доступ по API-ключу.

### 2.3 Валидация и лимиты

- Zod-схемы на ввод (логин, пароль, суммы, slug, заявки). ✅
- Лимиты размера тела: auth 512 KB, default 1 MB, webhook 256 KB. ✅
- Лимиты сумм (платёж, вывод), лимиты количества выводов. ✅
- Rate limit: auth, registration-requests, pay (IP + slug), webhook. ✅

### 2.4 Секреты и логирование

- Секреты только из `process.env`, в логгере есть санитизация (REDACT_KEYS, «password», «secret», «token», «apiKey» и т.д.). ✅
- В коде не видно логирования паролей или API-ключей. ✅

### 2.5 Платёжный контур

- Подпись вебхука Paygine проверяется (`verifyPaygineCallbackSignature`). ✅
- Stub-шлюз с `PAYMENT_WEBHOOK_SECRET` в production без секрета отклоняет. ✅
- Open redirect: в production baseUrl только из `NEXT_PUBLIC_APP_URL`. ✅

---

## 3. Корректность логики

### 3.1 Баланс и выплаты

- Баланс: зачисленные транзакции (SUCCESS) минус выполненные выплаты (COMPLETED), учёт комиссий. ✅
- Создание выплаты: проверка баланса, суточные/месячные лимиты, автоподтверждение и отправка в Paygine по правилам. ✅
- Идемпотентность вебхука: по `reference` (id транзакции или выплаты), повторный приход не дублирует списание. ✅

### 3.2 Платёжная ссылка и оплата

- GET/POST `/api/pay/[slug]`: проверка существования ссылки, блокировки получателя, rate limit по IP и slug, валидация тела (Zod). ✅
- Создание платежа: idempotencyKey, при повторном запросе — возврат существующей транзакции/редирект. ✅

### 3.3 Ссылки (POST /api/links)

- При переданном `slug` — проверка конфликта; при автогенерации — до `MAX_SLUG_RETRIES` попыток. Переменная `slug` в ветке без явного slug инициализируется в цикле (`slug = generateSlug()` перед циклом). ✅ Логика корректна.

### 3.4 Чек (receipt)

- `payout.details` в схеме обязательная строка — вызов `payout.details.startsWith("Телефон")` безопасен. ✅

---

## 4. Качество кода

### 4.1 Структура

- Разделение: auth, auth-or-api-key, api-key-auth, validations, payment gateway, middleware. ✅
- Повторное использование: общие хелперы (parseJsonWithLimit, jsonError, internalError), единый формат ошибок. ✅

### 4.2 Типы и ошибки

- Типы возврата auth (response vs userId) согласованы. ✅
- В production внутренние детали не утекают в ответ (internalError). ✅
- Обработка Zod-ошибок с понятными сообщениями. ✅

### 4.3 Миграция API-ключа

- Новые ключи: только prefix + hash в БД; legacy-поиск по `apiKey` сохранён до выполнения скрипта миграции. ✅
- Скрипт `scripts/migrate-api-key-to-hash.ts` корректен; после применения миграции схемы его нужно выполнить один раз. ✅

---

## 5. Рекомендации (низкий приоритет)

1. **Роль по API-ключу:** при необходимости доступа суперадмина по API к чужим чекам — в маршрутах, где нужна роль, подгружать пользователя из БД по `userId` и проверять `role`.
2. **CSRF на refresh:** теоретически можно добавить проверку CSRF на POST /api/auth/refresh (сейчас только rate limit). Риск низкий: refresh token в httpOnly cookie, запрос с другого сайта не принесёт cookie с того же origin.
3. **Документация миграции:** в README или в деплой-инструкции явно указать: после миграции `20260227000000_add_api_key_hash` выполнить `npx tsx scripts/migrate-api-key-to-hash.ts`.
4. **Колонка apiKey в схеме:** после того как все ключи переведены на хеш и скрипт миграции везде откатан, можно удалить колонку `apiKey` из схемы и убрать legacy-ветку в `api-key-auth.ts`.

---

## 6. AQB Summary

- **[AQB:Sec]** CSRF на auth-эндпоинтах; API-ключ в виде хеша; секреты из env; санитизация логов; проверка подписи вебхука; rate limit и лимиты тела.
- **[AQB:Test]** Есть тесты (csrf, rate-limit, validation); при изменении auth/API-ключа желательно добавить тесты на проверку по хешу и legacy.
- **[AQB:Perf]** Критичные пути без явных O(n²); rate limit in-memory — при масштабировании вынести в Redis.
- **[AQB:Maint]** Модули разделены, типы и контракты понятны; миграция API-ключа документирована в коде и в скрипте.
- **[AQB:DevOps]** Конфигурация через env; для production обязателен NEXT_PUBLIC_APP_URL и SUPERADMIN_PASSWORD при seed.
- **[AQB:Doc]** AUDIT_FINDINGS и данный QUALITY_AUDIT актуализируют состояние; README/деплой можно дополнить шагом миграции API-ключа.
- **[AQB:Biz]** Требования к безопасности и платёжному контуру соблюдены; оставшиеся пункты — улучшения, не блокеры.

---

**Итог:** Критические и важные пункты первого аудита закрыты. Текущее состояние кода и безопасности оценивается как хорошее; оставшиеся рекомендации — точечные и низкого приоритета.

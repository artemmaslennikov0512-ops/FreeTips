# Отчёт аудита проекта 1tips (27.02.2026)

Проведён обзор структуры проекта, зависимостей, связей между компонентами, API, аутентификации, платёжных потоков и валидации. Ниже — уязвимости, недочёты и рекомендации.

---

## 1. Критические и важные уязвимости

### 1.1 [Критично] Отсутствие проверки CSRF на логине и регистрации

**Где:** `app/api/auth/login/route.ts`, `app/api/auth/register/route.ts`

**Проблема:** Маршруты `POST /api/auth/login` и `POST /api/auth/register` не проверяют CSRF-токен. Фронтенд отправляет заголовок `x-csrf-token` (через `getCsrfHeader()`), но API его не проверяет. Злоумышленник с другого сайта может инициировать запрос на логин/регистрацию от имени жертвы; при использовании fetch ответ с `accessToken` может попасть в скрипт атакующего.

**Рекомендация:** Добавить проверку CSRF (как в `app/api/auth/logout/route.ts` через `verifyCsrfFromRequest(request)`) в начале обработчика POST для login и register. Исключать проверку только для запросов с `Authorization: Bearer` (для логина/регистрации Bearer по смыслу не используется, поэтому проверка CSRF обязательна).

---

### 1.2 [Важно] API-ключ в открытом виде в БД и в ответе профиля

**Где:**  
- `prisma/schema.prisma`: поле `User.apiKey` — строка до 64 символов, хранится в открытом виде.  
- `lib/api-key-auth.ts`: поиск по `where: { apiKey }` — сравнение в константное время есть, но ключ в БД не хешируется.  
- `app/api/profile/route.ts`: в ответе GET возвращается `apiKey: profile.apiKey ?? null` (строка 108).

**Проблема:**  
- При утечке БД все API-ключи становятся скомпрометированы.  
- Ответ GET /api/profile отдаёт ключ в теле — при логировании ответов, прокси или утечке логов ключ утекает.

**Рекомендация:**  
- Хранить в БД только хеш API-ключа (например, SHA-256), при создании ключа сохранять хеш, при проверке — сравнивать хеш от заголовка с хранимым (с сохранением timing-safe сравнения).  
- В ответе GET /api/profile не возвращать сам ключ; возвращать только факт наличия ключа (например, `hasApiKey: true/false`) или маскированную версию (например, последние 4 символа). Полный ключ показывать только один раз при создании (POST /api/profile/api-key), как сейчас.

---

### 1.3 [Важно] В production без NEXT_PUBLIC_APP_URL платёжный редирект ломается

**Где:** `lib/get-base-url.ts` — в production при отсутствии `NEXT_PUBLIC_APP_URL` возвращается `""`. В `lib/payment/paygine-gateway.ts` при пустом `baseUrl` создание платежа возвращает ошибку «Не указан baseUrl для редиректа».

**Проблема:** Это защита от open redirect (не использовать origin из запроса в production), но при забытой переменной окружения приём платежей перестаёт работать без явной ошибки конфигурации.

**Рекомендация:** В production при отсутствии `NEXT_PUBLIC_APP_URL` логировать предупреждение при старте или при первом создании платежа; в ответе API при пустом baseUrl возвращать сообщение вроде «Задайте NEXT_PUBLIC_APP_URL в production».

---

## 2. Средние недочёты и риски

### 2.1 Rate limit in-memory при нескольких инстансах

**Где:** `lib/middleware/rate-limit.ts` — используется `Map` в памяти.

**Проблема:** При горизонтальном масштабировании (несколько инстансов Next.js) лимиты не общие — с каждого инстанса можно делать до лимита запросов. В коде это уже указано в комментарии.

**Рекомендация:** Для production с несколькими инстансами вынести счётчики в Redis (или аналог) и заменить использование Map на Redis INCR/EXPIRE.

---

### 2.2 Webhook при исключении всегда возвращает 200

**Где:** `app/api/payment/webhook/route.ts`, `app/api/v1/webhooks/paygine/route.ts` — в блоке `catch` возвращается `200 OK` с телом `"ok"`.

**Проблема:** Paygine при 200 не повторяет запрос. При внутренней ошибке (например, падение при обновлении БД) провайдер считает доставку успешной, повторной отправки не будет — возможна потеря события.

**Рекомендация:** В catch возвращать 500 (или 503), чтобы провайдер повторил запрос; при этом обеспечить идемпотентность обработки вебхука по `reference`/id транзакции.

---

### 2.3 Логирование и секреты в profile

**Где:** `app/api/profile/route.ts` — в запросе к Paygine передаются `sector` и `password` из `process.env`. В логах не должны попадать секреты.

**Проблема:** Если где-то логируется контекст (например, объект с `sector`/`password`), возможна утечка. В текущем коде прямого логирования этих переменных не видно — остаётся общий риск при изменении кода.

**Рекомендация:** Не передавать и не логировать пароли/секреты; при необходимости логировать только факт вызова (например, `sdRef` без пароля).

---

### 2.4 Пароль суперадмина по умолчанию в seed

**Где:** `prisma/seed.ts`: `const superAdminPassword = process.env.SUPERADMIN_PASSWORD || "ChangeMe123!"`.

**Проблема:** Если в production не задать `SUPERADMIN_PASSWORD`, будет использован дефолтный пароль.

**Рекомендация:** В production не подставлять дефолт: если `SUPERADMIN_PASSWORD` не задан — не создавать/не обновлять суперадмина с паролем или завершать seed с ошибкой.

---

## 3. Потенциальные ошибки и некорректная работа

### 3.1 POST /api/links — переменная slug в ветке без slug

**Где:** `app/api/links/route.ts`, ветка `else if (validated.success)`.

**Проблема:** Используется `slug = generateSlug()` перед циклом, затем в цикле `db.tipLink.findUnique({ where: { slug } })`. При первом заходе в цикл `slug` уже определён — логика корректна. Но если в будущем поменять порядок (например, сначала цикл), возможна ошибка «slug is undefined». Сейчас бага нет, но код хрупкий.

**Рекомендация:** Явно инициализировать `slug` в блоке (например, `let slug = generateSlug();`) и при рефакторинге не полагаться на неочевидный порядок присваиваний.

---

### 3.2 Баланс: расчёт и отображение Paygine

**Где:** `lib/balance.ts` считает баланс по транзакциям и выплатам; `app/api/profile/route.ts` при наличии Paygine подменяет отображаемый баланс на `sdGetBalance()`.

**Проблема:** Если запрос к Paygine падает или возвращает ошибку, в ответе профиля используется «локальный» баланс (`balanceCalculated`). Это приемлемо, но пользователь может не понять расхождение между «балансом в системе» и «балансом в Paygine» при сбоях интеграции.

**Рекомендация:** Документировать в API или в интерфейсе, что при настроенном Paygine баланс берётся из Paygine; при ошибке запроса — показывать локальный расчёт и, по возможности, индикатор «данные Paygine временно недоступны».

---

### 3.3 Валидация id в receipt

**Где:** `app/api/payouts/[id]/receipt/route.ts` — `id` приходит из `params`. Prisma `findUnique({ where: { id } })` при невалидном формате cuid вернёт null — разницы между «не найден» и «неверный id» нет.

**Проблема:** Не критично; с точки зрения безопасности проверка владельца (или SUPERADMIN) выполняется после загрузки заявки — утечки данных нет.

**Рекомендация:** Опционально — явно проверять формат `id` (например, длина и допустимые символы для cuid) и возвращать 400 при явно неверном формате.

---

## 4. Что сделано хорошо

- **Авторизация:** JWT (jose), refresh в httpOnly cookie, проверка сессии в БД при refresh, блокировка пользователя учитывается.
- **RBAC:** Админ-маршруты защищены `requireRole(["ADMIN"|"SUPERADMIN"])`; SUPERADMIN имеет доступ к эндпоинтам ADMIN.
- **Чеки (receipt):** Доступ только владельцу заявки или SUPERADMIN; проверка `payout.userId === userId`.
- **Вебхуки:** Подпись Paygine проверяется (`verifyPaygineCallbackSignature`); stub-шлюз с `PAYMENT_WEBHOOK_SECRET` в production без секрета отклоняет запрос.
- **Rate limit:** На auth, registration-requests, pay по IP/slug, webhook.
- **Валидация:** Zod-схемы, лимиты размера тела (auth, default, webhook), лимиты сумм.
- **CSRF:** Реализован double-submit, проверка на logout при отсутствии Bearer; исключения только для webhook и Bearer.
- **Open redirect:** В production baseUrl не берётся из request, только из `NEXT_PUBLIC_APP_URL`.
- **Секреты:** В коде не захардкожены, используются переменные окружения.
- **Сравнение ключей/токенов:** timing-safe для CSRF и API-ключа (хеш + timingSafeEqual).

---

## 5. Зависимости и конфигурация

- Next.js 16, React 19, Prisma 6, PostgreSQL — актуальный стек.
- Секреты задаются через `.env`; в репозитории есть `.env.example` без значений.
- Рекомендуется периодически проверять `npm audit` и обновлять зависимости.

---

## 6. AQB Summary (внутренний обзор)

- **[AQB:Sec]** Рекомендовано: добавить CSRF на login/register; не возвращать API-ключ в GET profile, хранить хеш ключа в БД; не подставлять дефолтный пароль суперадмина в production.
- **[AQB:Test]** Есть тесты (csrf-client, rate-limit, validation); стоит добавить проверку CSRF для login/register в тестах.
- **[AQB:Perf]** Rate limit in-memory — при масштабировании перейти на Redis; критические пути без очевидных O(n²).
- **[AQB:Maint]** Структура и разделение auth/or-api-key, paygine-gateway, validations — понятные; рекомендации выше улучшат поддерживаемость.
- **[AQB:DevOps]** Конфигурация через env; в production обязателен `NEXT_PUBLIC_APP_URL` для платежей — стоит явно описать в README/deploy.
- **[AQB:Doc]** Есть SECURITY_AUDIT.md, SECURITY_CHECK.md; в этот отчёт внесены новые пункты (CSRF auth, API key, baseUrl).
- **[AQB:Biz]** Соответствие требованиям платёжного и личного кабинета сохранено; исправления не меняют сценарии, только усиливают безопасность и предсказуемость.

---

## 7. Приоритеты исправлений

| Приоритет | Действие |
|-----------|----------|
| P0       | Добавить проверку CSRF на POST /api/auth/login и POST /api/auth/register. |
| P1       | Не возвращать API-ключ в GET /api/profile; хранить в БД хеш API-ключа. |
| P1       | В production при отсутствии NEXT_PUBLIC_APP_URL логировать/возвращать явную ошибку конфигурации. |
| P2       | В seed не использовать дефолтный пароль суперадмина в production. |
| P2       | В webhook при ошибке в catch возвращать 5xx для повторной доставки (с идемпотентностью). |
| P3       | При масштабировании вынести rate limit в Redis. |

Если нужно, могу предложить конкретные патчи (диффы) по пунктам P0 и P1.
